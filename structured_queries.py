"""
    This script generates structured summaries of Zendesk tickets. The summaries are generated by
    answering a series of predefined questions based on the comments in the ticket. The questions are
    defined in the `QUESTION_DETAIL` list. The answers are generated using the `TreeSummarize` response
    synthesizer from the `llama_index` package.
"""
import os
import time
import llama_index
from llama_index.core.settings import Settings
from llama_index.core import SimpleDirectoryReader
from llama_index.core.response_synthesizers import TreeSummarize
# from llama_index.core.evaluation import FaithfulnessEvaluator
from config import COMPANY, SUMMARY_ROOT
from zendesk_utils import commentPaths

SUMMARY_SUB_ROOT = os.path.join(SUMMARY_ROOT, "structured")

summariser = TreeSummarize(verbose=False)

# evaluator = FaithfulnessEvaluator(llm=llm)

assert COMPANY, "Set COMPANY in config.py before running this script"
BASE_PROMPT = f"The following text is a series of messages from a {COMPANY} support ticket."

def makePrompt(text):
    "Returns a prompt created by appending `text` to the base prompt `BASE_PROMPT`."
    return f"{BASE_PROMPT}\n{text}"

QUESTION_DETAIL = [
    ("Summary", "Summarise the whole conversation in one sentence."),

    ("Problems", """List the problems raised in the ticket.
Use a numbered list.
Don't add a prologue or epilogue to the list.
Problems are issues that need to be resolved, such as a bug, a feature request.
Questions about how to use the product are not problems.
Responses to problems are not problems.
Each problem should be a single sentence describing the problem.
When there is no problem, don't write a line.
If there are multiple problems, order them by importance, most important first."""),

  ("Status", """What is the current status of the ticket?
Is it open, closed, or pending?
If it is closed, what was the resolution?
If it is pending, what is the next action?
If it is open, what is the current problem?
Do not include any other information in this answer.
Your answer should be one sentence for status and optionally one sentence for the resolution or next action.
"""),

    ("Participants", """List the participants and who they work for.
Use a numbered list.
Don't add a prologue or epilogue to the list.
Use the format: 'Name: Company.'
List the customer first and {COMPANY} staff last.
"""),

    ("Events", """List the key events and the date they occurred.
An event is something that happens, such as a problem being reported, a solution being proposed, or a resolution being reached.
Don't include contacts, responses, or other non-events.
Use a numbered list.
Don't add a prologue or epilogue to the list.
Questions about how to use the product are not events.
Responses to problems are not events.
Log lines are not events.
When there is no event, don't write a line.
Use the format: 'Date: Event.'
Format the date as 'YYYY-MM-DD'.
Order the list by date, earliest first."""),

    ("Logs", """List all the log lines from the messages.
Use a numbered list.
Order the list by date, earliest first.
Don't add a prologue or epilogue to the list.
When there is no log line, don't write a line.
Write the full log line.
Log lines are lines that start with a date and a status such as INFO, WARN, DEBUG or ERROR.
Example: 2022-01-27 13:31:43,628  WARN
Example: 2022-01-26 12:40:18,380 DEBUG ClientManagerImpl
Example: ERROR  | wrapper  | 2022/01/27 13:30:58 | JVM exited unexpectedly. """),
]

QUESTIONS = [question for question, _ in QUESTION_DETAIL]
QUESTION_PROMPT = {short: makePrompt(detail) for (short, detail) in QUESTION_DETAIL}

if False:
    prompts = summariser.get_prompts()
    print(f"{len(prompts)} Prompts =========================")
    for k, p in prompts.items():
        print(f"**Prompt: {k} ---------------")
        print(p.get_template())
        print("*" * 80)
    assert False, "Done"

def makeAnswer(question, answer):
    "Returns `question` and `answer` formatted into a structured answer string."
    question = f"{question.upper()}:"
    return f"{question:13} -------------------------------------------------------------*\n{answer}"

class StructuredSummariser:
    """
    A class that generates structured summaries for Zendesk tickets by answering a set of predefined
    questions.

    Attributes:
        summary_dir: The directory where the summaries will be stored.

    Methods:
        __init__(self, llm, model): Initializes the StructuredSummariser object.
        summaryPath(self, ticketNumber): Returns the file path for where we store the summary of a
                Zendesk ticket.
        summariseTicket(self, ticketNumber): Summarizes a Zendesk ticket by generating answers to
            predefined questions.
    """

    def __init__(self, llm, model):
        """
        Initializes this summariser.

        llm: The LLM used for summarisation.
        model: The LLM model name.
        """
        self.summary_dir = os.path.join(SUMMARY_SUB_ROOT, model).replace(":", "_")
        os.makedirs(self.summary_dir, exist_ok=True)
        Settings.embed_model = "local"
        Settings.llm = llm

    def summaryPath(self, ticketNumber):
        "Returns the file path for where we store the summary of Zendesk ticket `ticketNumber`."
        assert self.summary_dir
        return os.path.join(self.summary_dir, f"{ticketNumber}.txt")

    def summariseTicket(self, ticketNumber):
        """
        Summarizes the ticket `ticketNumber` by generating answers to a set of predefined questions.

        Returns: Structured text containing the answers to each of the questions based on the
                comments in the ticket.
        """
        t0 = time.time()
        input_files = commentPaths(ticketNumber)
        reader = SimpleDirectoryReader(input_files=input_files)
        docs = reader.load_data()
        texts = [doc.text for doc in docs]
        print(f"Loaded {len(texts)} comments in {time.time() - t0:.1f} seconds")
        questionAnswer = {}
        for question in reversed(QUESTIONS):
            t0 = time.time()
            prompt = QUESTION_PROMPT[question]
            answer = summariser.get_response(prompt, texts)
            questionAnswer[question] = answer.strip()
            print(f"{time.time() - t0:4.1f} seconds to answer {question}")

        return "\n\n".join(makeAnswer(question, questionAnswer[question])
            for question in QUESTIONS)

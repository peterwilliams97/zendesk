""" Analyse the summaries generated by the RAG summariser.
"""
import os
import re
import glob
from config import DIVIDER
from utils import load_text, text_lines
from rag_summariser import STRUCTURED_SUB_ROOT

MODEL = "llama2"
summary_root = os.path.join(STRUCTURED_SUB_ROOT, MODEL)
N = 50

RE_DIVIDER = re.compile(r"^\s*([A-Z\s]+):.*%s" % DIVIDER)
RE_RESULT = re.compile(r"^\s*(\d+)\.")
RE_SIZE = re.compile(r"comments_size:\s*(\d+),", re.MULTILINE)

def numberedLines(lines):
    "Extracts numbered lines with increasing numbers from `lines`."
    matches = []
    last_n = -1
    for line in lines:
        m = RE_RESULT.match(line)
        if not m:
            continue
        n = int(m.group(1))
        if n < last_n + 1:
            break
        matches.append(line)
        last_n = n
    return matches

def extractCommentsSize(text):
    "Returns the size of the comments data written in JSON in `text`."
    if "[No comments for ticket]" in text:
        return 0
    m = RE_SIZE.search(text)
    assert m, f"Failed to match\n\t{text}"
    return int(m.group(1))

def summarySections(text):
    "Returns the size of the comments and sections of the summary `text`."

    lines = text_lines(text)
    size = extractCommentsSize(text[:500])
    divider_indexes = [idx for idx, line in enumerate(lines) if DIVIDER in line]
    divider_indexes.append(len(lines))
    sections = {}
    for i0, i1 in zip(divider_indexes[:-1], divider_indexes[1:]):
        line = lines[i0]
        m = RE_DIVIDER.match(line)
        assert m, f"Failed to match\n\t{line} with\n\t{RE_DIVIDER.pattern}"
        key = m.group(1)
        sections[key] = numberedLines(lines[i0+1:i1])

    return size, sections

print(f"Summaries for {summary_root}")
assert os.path.exists(summary_root), f"Missing {summary_root}"
summary_paths = glob.glob(os.path.join(summary_root, "*.txt"))
print(f"Found {len(summary_paths)} summaries.")

# (size, score, summary_path)
result_list = []
for summary_path in summary_paths:
    text = load_text(summary_path)
    if "Jane Doe" in text or "John Doe" in text:
        continue
    lines = text_lines(text)
    size, sections = summarySections(text)
    if not all([k in sections for k in ["PROBLEMS", "PARTICIPANTS", "EVENTS"]]):
        continue
    score = len(sections["PROBLEMS"]), len(sections["PARTICIPANTS"]), len(sections["EVENTS"])
    result_list.append((size, score, summary_path))

def resultString(result):
    "Returns a formatted string describing `result`."
    size, score, summary_path = result
    problems, participants, events = score
    total = problems + participants + events
    summary_path = os.path.abspath(summary_path)
    return f"{size:6}  ({problems:2}, {participants:2}, {events:3}) {total:3}  {summary_path}"

def showResults(result_list, n=5):
    "Prints the top `n` results from  `result_list`."
    for result in result_list[:n]:
        print(resultString(result))

def ticketNumber(result):
    "Extracts the ticket number from `result`."
    size, score, summary_path = result
    name = os.path.basename(summary_path)
    return int(name.split(".")[0])

# {ticket_number: (size, score, summary_path)}
ticket_result = {}

result_list.sort(key=lambda x: x[1][0] + x[1][1] + x[1][2], reverse=True)
print(f"Top {N} summaries: Total score, Problems, Participants, Events")
showResults(result_list)
for result in result_list[:N]:
    ticket_result[ticketNumber(result)] = result

result_list.sort(key=lambda x: x[1][0], reverse=True)
print(f"Top {N} summaries: Total score, Problems,")
showResults(result_list)
for result in result_list[:N]:
    ticket_result[ticketNumber(result)] = result

result_list.sort(key=lambda x: x[1][1], reverse=True)
print(f"Top {N} summaries: Total score, Participants,")
showResults(result_list)
for result in result_list[:N]:
    ticket_result[ticketNumber(result)] = result

result_list.sort(key=lambda x: x[1][2], reverse=True)
print(f"Top {N} summaries: Total score, Events,")
showResults(result_list)
for result in result_list[:N]:
    ticket_result[ticketNumber(result)] = result

def resultKey(k):
    "Sort key function for sorting the top summaries."
    result = ticket_result[k]
    size, score, summary_path = result
    n = 3*score[0] + 2*score[1] + score[2]
    return -n / (size+5000), -score[0], -score[1], -score[2]

top_result_ticket_numbers = sorted(ticket_result.keys(), key=resultKey)
print(f"Top summaries: {len(top_result_ticket_numbers)} of {4*N}")
for i, k in enumerate(top_result_ticket_numbers[:N]):
    result = ticket_result[k]
    print(f"{i+1:2}: {resultString(result)}")
